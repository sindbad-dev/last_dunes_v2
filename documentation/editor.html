<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>√âditeur de Niveaux - Last Dunes</title>
    <style>
        body {
            margin: 0;
            background: #1a1a1a;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }

        #container {
            display: flex;
            gap: 20px;
        }

        #canvas-area {
            flex: 1;
        }

        #sidebar {
            width: 380px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #gameCanvas {
            border: 2px solid #555;
            background: #2a2a2a;
            cursor: crosshair;
            display: block;
        }

        .tool-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 5px;
        }

        .tool-section h3 {
            margin-top: 0;
            color: #ffd700;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 3px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            margin: 5px 5px 5px 0;
            background: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #45a049;
        }

        button.active {
            background: #ffd700;
            color: #000;
            font-weight: bold;
        }

        button.delete {
            background: #f44336;
        }

        button.delete:hover {
            background: #da190b;
        }

        .tool-btn {
            min-width: 80px;
            padding: 12px;
            margin: 5px;
            background: #555;
            font-size: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .tool-btn.active {
            background: #ffd700;
            box-shadow: 0 0 10px #ffd700;
        }

        .tool-btn:hover {
            background: #666;
        }

        .tool-btn.active:hover {
            background: #ffd700;
        }

        .challenge-item, .object-item {
            background: #444;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ffd700;
        }

        .challenge-item:hover, .object-item:hover {
            background: #555;
        }

        .coords {
            color: #0ff;
            font-size: 12px;
        }

        .info {
            background: #1a4d7a;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .grid-info {
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }

        input[type="color"] {
            width: 60px;
            height: 35px;
            border: none;
            cursor: pointer;
        }

        .emoji-picker {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .emoji-btn {
            padding: 5px 10px;
            font-size: 20px;
            background: #555;
            min-width: 40px;
        }

        .emoji-btn.selected {
            background: #4CAF50;
        }

        .object-library {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            margin: 10px 0;
        }

        .object-lib-btn {
            padding: 10px;
            font-size: 28px;
            background: #444;
            border: 2px solid #666;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .object-lib-btn:hover {
            background: #555;
            transform: scale(1.1);
        }

        .object-lib-btn.selected {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .layer-indicator {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tab {
            padding: 8px 15px;
            background: #444;
            border: none;
            cursor: pointer;
            flex: 1;
            border-radius: 5px 5px 0 0;
        }

        .tab.active {
            background: #333;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <h1>üó∫Ô∏è √âditeur de Niveaux - Last Dunes</h1>

    <div id="container">
        <div id="canvas-area">
            <div class="info">
                <strong>Mode actuel:</strong> <span id="current-mode">S√©lection</span><br>
                <strong>Outil:</strong> <span id="current-tool">Aucun</span><br>
                <small>Cliquez sur un outil √† droite, puis cliquez/glissez sur la carte pour dessiner</small>
            </div>
            <canvas id="gameCanvas" width="800" height="800"></canvas>
            <div class="grid-info">
                Grille: <span id="grid-size">40</span>px |
                Position souris: <span id="mouse-pos">-</span> |
                Calque: <span id="current-layer">Terrain</span>
            </div>
        </div>

        <div id="sidebar">
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab('terrain')">Terrain</button>
                <button class="tab" onclick="switchTab('objects')">Objets</button>
                <button class="tab" onclick="switchTab('challenges')">Challenges</button>
                <button class="tab" onclick="switchTab('config')">Config</button>
            </div>

            <!-- Terrain Tab -->
            <div id="tab-terrain" class="tab-content">
                <div class="tool-section">
                    <h3>üé® Outils de Dessin</h3>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;">
                        <button class="tool-btn" onclick="selectTool('wall')" title="Mur">
                            üß±<br><small>Mur</small>
                        </button>
                        <button class="tool-btn" onclick="selectTool('water')" title="Eau">
                            üíß<br><small>Eau</small>
                        </button>
                        <button class="tool-btn" onclick="selectTool('eraser')" title="Gomme">
                            üóëÔ∏è<br><small>Gomme</small>
                        </button>
                    </div>
                    <div style="margin-top: 10px;">
                        <label><input type="checkbox" id="brush-mode"> Mode Pinceau (cliquer-glisser)</label>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>üìä Statistiques</h3>
                    <div>Murs: <span id="walls-count">0</span></div>
                    <div>Eau: <span id="water-count">0</span></div>
                    <button onclick="clearLayer('walls')" class="delete">Effacer tous les murs</button>
                    <button onclick="clearLayer('water')" class="delete">Effacer toute l'eau</button>
                </div>
            </div>

            <!-- Objects Tab -->
            <div id="tab-objects" class="tab-content" style="display:none;">
                <div class="tool-section">
                    <h3>ü™ë Biblioth√®que d'Objets</h3>
                    <div class="object-library">
                        <button class="object-lib-btn" onclick="selectObject('üö™')" title="Porte">üö™</button>
                        <button class="object-lib-btn" onclick="selectObject('üì¶')" title="Coffre">üì¶</button>
                        <button class="object-lib-btn" onclick="selectObject('ü™ë')" title="Chaise">ü™ë</button>
                        <button class="object-lib-btn" onclick="selectObject('üõèÔ∏è')" title="Lit">üõèÔ∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('üî•')" title="Chemin√©e">üî•</button>
                        <button class="object-lib-btn" onclick="selectObject('üìú')" title="Parchemin">üìú</button>
                        <button class="object-lib-btn" onclick="selectObject('ü™î')" title="Lampe">ü™î</button>
                        <button class="object-lib-btn" onclick="selectObject('üïØÔ∏è')" title="Bougie">üïØÔ∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('‚ö±Ô∏è')" title="Urne">‚ö±Ô∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('üè∫')" title="Vase">üè∫</button>
                        <button class="object-lib-btn" onclick="selectObject('üóùÔ∏è')" title="Cl√©">üóùÔ∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('‚öîÔ∏è')" title="√âp√©e">‚öîÔ∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('üõ°Ô∏è')" title="Bouclier">üõ°Ô∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('üìö')" title="Livres">üìö</button>
                        <button class="object-lib-btn" onclick="selectObject('ü™ü')" title="Fen√™tre">ü™ü</button>
                        <button class="object-lib-btn" onclick="selectObject('ü™ú')" title="√âchelle">ü™ú</button>
                        <button class="object-lib-btn" onclick="selectObject('‚õìÔ∏è')" title="Cha√Ænes">‚õìÔ∏è</button>
                        <button class="object-lib-btn" onclick="selectObject('ü¶¥')" title="Os">ü¶¥</button>
                    </div>
                    <label>Ou entrez un emoji:</label>
                    <input type="text" id="custom-object" placeholder="üéØ" maxlength="2">
                    <button onclick="selectObject(document.getElementById('custom-object').value)">Utiliser</button>
                </div>

                <div class="tool-section">
                    <h3>üìã Objets Plac√©s (<span id="objects-count">0</span>)</h3>
                    <div id="objects-list"></div>
                </div>
            </div>

            <!-- Challenges Tab -->
            <div id="tab-challenges" class="tab-content" style="display:none;">
                <div class="tool-section">
                    <h3>‚ûï Nouveau Challenge</h3>
                    <label>Nom:</label>
                    <input type="text" id="new-name" placeholder="Le Gardien">

                    <label>Type:</label>
                    <select id="new-type">
                        <option value="challenge">Challenge</option>
                        <option value="interaction">Interaction</option>
                        <option value="boss">Boss</option>
                    </select>

                    <label>Ic√¥ne:</label>
                    <div class="emoji-picker">
                        <button class="emoji-btn selected" onclick="selectChallengeEmoji(this, '‚öîÔ∏è')">‚öîÔ∏è</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'ü™£')">ü™£</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'üíÄ')">üíÄ</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'üóùÔ∏è')">üóùÔ∏è</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'üö™')">üö™</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'üìú')">üìú</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'üíé')">üíé</button>
                        <button class="emoji-btn" onclick="selectChallengeEmoji(this, 'üî•')">üî•</button>
                    </div>
                    <input type="text" id="new-icon" value="‚öîÔ∏è" maxlength="2">

                    <label>Couleur:</label>
                    <input type="color" id="new-color" value="#ff00ff">

                    <label>üñºÔ∏è Image du challenge (optionnel):</label>
                    <input type="file" id="challenge-image-upload" accept="image/png,image/jpg,image/jpeg,image/gif,image/webp">
                    <div id="challenge-image-preview" style="margin: 10px 0; display: none;">
                        <img id="preview-img" style="max-width: 200px; max-height: 150px; border: 2px solid #ffd700; border-radius: 8px; display: block;">
                        <button onclick="clearChallengeImage()" style="margin-top: 5px; background: #f44336; font-size: 12px;">‚ùå Supprimer l'image</button>
                    </div>
                    <small style="color: #aaa; display: block; margin-bottom: 10px;">
                        Importez une illustration pour ce challenge. L'image sera encod√©e dans le fichier JSON.
                    </small>

                    <label>Rayon de d√©clenchement:</label>
                    <input type="number" id="new-radius" value="1" min="0" max="5">

                    <label>Dialogue de pr√©visualisation:</label>
                    <textarea id="new-dialogue" rows="2" placeholder="Ses orbites vides vous fixent..."></textarea>

                    <label>üìù Cons√©quences des choix de cartes:</label>
                    <div style="background: #444; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <label style="font-size: 12px; color: #4CAF50;">‚ú® R√©ussite triomphale:</label>
                        <textarea id="outcome-success-triumph" rows="2" placeholder="Exemple: Vous pulv√©risez le gobelin et trouvez une cl√© secr√®te sur son cadavre." style="margin-bottom: 10px;">Vous triomphez brillamment.</textarea>

                        <label style="font-size: 12px; color: #8BC34A;">‚úì R√©ussite de justesse:</label>
                        <textarea id="outcome-success-narrow" rows="2" placeholder="Exemple: Vous assommez le gobelin apr√®s un combat difficile." style="margin-bottom: 10px;">Vous r√©ussissez de justesse.</textarea>

                        <label style="font-size: 12px; color: #FF9800;">‚ö†Ô∏è √âchec de justesse:</label>
                        <textarea id="outcome-fail-narrow" rows="2" placeholder="Exemple: Le gobelin vous blesse, vous perdez 1 point de vie." style="margin-bottom: 10px;">Vous √©chouez mais survivez.</textarea>

                        <label style="font-size: 12px; color: #F44336;">üíÄ √âchec catastrophique:</label>
                        <textarea id="outcome-fail-catastrophic" rows="2" placeholder="Exemple: Le gobelin vous frappe violemment, vous perdez 2 points de vie.">√âchec catastrophique.</textarea>

                        <small style="color: #aaa; display: block; margin-top: 8px;">
                            D√©crivez ce qui arrive au joueur selon le type de carte choisie.
                        </small>
                    </div>

                    <label>‚ù§Ô∏è Effets sur les points de vie:</label>
                    <div style="background: #444; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <label style="font-size: 12px;">R√©ussite triomphale (HP):</label>
                        <input type="number" id="hp-success-triumph" value="0" min="-10" max="10" style="width: 80px;">

                        <label style="font-size: 12px; margin-top: 5px;">R√©ussite de justesse (HP):</label>
                        <input type="number" id="hp-success-narrow" value="0" min="-10" max="10" style="width: 80px;">

                        <label style="font-size: 12px; margin-top: 5px;">√âchec de justesse (HP):</label>
                        <input type="number" id="hp-fail-narrow" value="-1" min="-10" max="10" style="width: 80px;">

                        <label style="font-size: 12px; margin-top: 5px;">√âchec catastrophique (HP):</label>
                        <input type="number" id="hp-fail-catastrophic" value="-2" min="-10" max="10" style="width: 80px;">

                        <small style="color: #aaa; display: block; margin-top: 8px;">
                            Positif = gain de HP, N√©gatif = perte de HP
                        </small>
                    </div>

                    <button onclick="addChallengeMode()">‚ûï Placer au prochain clic</button>
                    <button onclick="saveEditedChallenge()" style="background: #2196F3; display:none;" id="save-edit-btn">üíæ Sauvegarder les modifications</button>
                </div>

                <div class="tool-section">
                    <h3>üìã Challenges Plac√©s (<span id="challenge-count">0</span>)</h3>
                    <div id="challenges-list"></div>
                </div>
            </div>

            <!-- Config Tab -->
            <div id="tab-config" class="tab-content" style="display:none;">
                <div class="tool-section">
                    <h3>üñºÔ∏è Carte du Niveau</h3>
                    <label>Fichier PNG de la carte:</label>
                    <input type="file" id="map-upload" accept="image/png,image/jpg,image/jpeg">
                    <br>
                    <label>Ou URL de l'image:</label>
                    <input type="text" id="map-url" placeholder="assets/level1.png">
                    <button onclick="loadMapFromURL()">Charger URL</button>
                </div>

                <div class="tool-section">
                    <h3>‚öôÔ∏è Configuration</h3>
                    <label>Taille de grille (px):</label>
                    <input type="number" id="grid-size-input" value="40" min="10" max="100" onchange="updateGridSize()">

                    <label>Position de d√©part (X, Y):</label>
                    <input type="number" id="start-x" value="16" min="0" max="19" style="width:48%; display:inline-block">
                    <input type="number" id="start-y" value="25" min="0" max="19" style="width:48%; display:inline-block">

                    <label>‚ù§Ô∏è Points de vie maximum:</label>
                    <input type="number" id="max-health" value="3" min="1" max="10">
                    <small style="color: #aaa; display: block; margin-top: 5px;">
                        Nombre initial de points de vie du joueur (d√©faut: 3)
                    </small>
                </div>

                <div class="tool-section">
                    <h3>üíæ Export / Import</h3>
                    <button onclick="exportJSON()">üì• T√©l√©charger JSON</button>
                    <button onclick="copyJSON()">üìã Copier JSON</button>
                    <br>
                    <label>Importer JSON:</label>
                    <input type="file" id="json-upload" accept=".json" onchange="importJSON()">
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // State
        let gridSize = 40;
        let mapImage = null;
        let startPos = {x: 16, y: 25};
        let mouseGridPos = {x: 0, y: 0};

        // Data layers
        let walls = [];
        let water = [];
        let objects = [];
        let challenges = [];

        // Tool state
        let currentTool = null;
        let selectedIcon = '‚öîÔ∏è';
        let selectedObject = null;
        let waitingForChallenge = false;
        let isDrawing = false;
        let brushMode = false;
        let editingChallengeId = null;
        let currentChallengeImage = null; // Stores base64 encoded image

        // Active tab
        let activeTab = 'terrain';

        // Initialize
        render();

        // Image upload handler
        document.getElementById('challenge-image-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Check file size (limit to 500KB to keep JSON reasonable)
            if (file.size > 500000) {
                alert('‚ö†Ô∏è L\'image est trop grande (max 500 KB). Veuillez utiliser une image plus petite.');
                e.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                currentChallengeImage = event.target.result;

                // Show preview
                const previewDiv = document.getElementById('challenge-image-preview');
                const previewImg = document.getElementById('preview-img');
                previewImg.src = currentChallengeImage;
                previewDiv.style.display = 'block';
            };
            reader.readAsDataURL(file);
        });

        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / gridSize);
            const y = Math.floor((e.clientY - rect.top) / gridSize);
            mouseGridPos = {x, y};
            document.getElementById('mouse-pos').textContent = `(${x}, ${y})`;

            if (isDrawing && brushMode) {
                handleCanvasClick(e);
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            brushMode = document.getElementById('brush-mode').checked;
            handleCanvasClick(e);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Removed duplicate click listener - mousedown already handles clicks

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / gridSize);
            const y = Math.floor((e.clientY - rect.top) / gridSize);

            if (x < 0 || y < 0 || x >= 20 || y >= 20) return;

            // Challenge placement
            if (waitingForChallenge) {
                placeChallenge(x, y);
                waitingForChallenge = false;
                canvas.style.cursor = 'crosshair';
                updateCurrentMode();
                return;
            }

            // Object placement
            if (selectedObject) {
                placeObject(x, y, selectedObject);
                return;
            }

            // Terrain tools
            if (currentTool === 'wall') {
                toggleTile(walls, x, y);
                updateStats();
            } else if (currentTool === 'water') {
                toggleTile(water, x, y);
                updateStats();
            } else if (currentTool === 'eraser') {
                removeTile(walls, x, y);
                removeTile(water, x, y);
                removeObject(x, y);
                updateStats();
                updateObjectsList();
            }

            render();
        }

        function toggleTile(layer, x, y) {
            const index = layer.findIndex(t => t.x === x && t.y === y);
            if (index === -1) {
                layer.push({x, y});
            } else {
                layer.splice(index, 1);
            }
        }

        function removeTile(layer, x, y) {
            const index = layer.findIndex(t => t.x === x && t.y === y);
            if (index !== -1) {
                layer.splice(index, 1);
            }
        }

        function placeObject(x, y, emoji) {
            // Remove existing object at same position
            removeObject(x, y);
            objects.push({x, y, emoji});
            updateObjectsList();
            render();
        }

        function removeObject(x, y) {
            const index = objects.findIndex(o => o.x === x && o.y === y);
            if (index !== -1) {
                objects.splice(index, 1);
            }
        }

        function placeChallenge(x, y) {
            const challengeData = {
                name: document.getElementById('new-name').value || 'Nouveau Challenge',
                type: document.getElementById('new-type').value,
                coordinates: {x, y},
                triggerRadius: parseInt(document.getElementById('new-radius').value),
                icon: selectedIcon,
                color: document.getElementById('new-color').value,
                description: '',
                dialogue_preview: document.getElementById('new-dialogue').value || 'Un challenge appara√Æt...',
                outcomes: {
                    success_narrow: document.getElementById('outcome-success-narrow').value || 'Vous r√©ussissez de justesse.',
                    success_triumph: document.getElementById('outcome-success-triumph').value || 'Vous triomphez brillamment.',
                    fail_narrow: document.getElementById('outcome-fail-narrow').value || 'Vous √©chouez mais survivez.',
                    fail_catastrophic: document.getElementById('outcome-fail-catastrophic').value || '√âchec catastrophique.'
                },
                healthEffects: {
                    success_triumph: parseInt(document.getElementById('hp-success-triumph').value) || 0,
                    success_narrow: parseInt(document.getElementById('hp-success-narrow').value) || 0,
                    fail_narrow: parseInt(document.getElementById('hp-fail-narrow').value) || -1,
                    fail_catastrophic: parseInt(document.getElementById('hp-fail-catastrophic').value) || -2
                }
            };

            // Add image if one is uploaded
            if (currentChallengeImage) {
                challengeData.image = currentChallengeImage;
            }

            if (editingChallengeId) {
                // Update existing challenge
                const index = challenges.findIndex(ch => ch.id === editingChallengeId);
                if (index !== -1) {
                    challenges[index] = {
                        ...challenges[index],
                        ...challengeData
                    };
                }
                editingChallengeId = null;
                document.getElementById('save-edit-btn').style.display = 'none';
            } else {
                // Create new challenge
                const challenge = {
                    id: `challenge_${Date.now()}`,
                    ...challengeData
                };
                challenges.push(challenge);
            }

            // Clear the image after placing
            clearChallengeImage();

            updateChallengesList();
            render();
        }

        function selectTool(tool) {
            currentTool = tool;
            selectedObject = null;
            waitingForChallenge = false;

            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');

            updateCurrentMode();
        }

        function selectObject(emoji) {
            if (!emoji) return;
            selectedObject = emoji;
            currentTool = null;
            waitingForChallenge = false;

            document.querySelectorAll('.object-lib-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.textContent.includes(emoji));
            });

            updateCurrentMode();
        }

        function selectChallengeEmoji(btn, emoji) {
            document.querySelectorAll('.emoji-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            selectedIcon = emoji;
            document.getElementById('new-icon').value = emoji;
        }

        function clearChallengeImage() {
            currentChallengeImage = null;
            document.getElementById('challenge-image-upload').value = '';
            document.getElementById('challenge-image-preview').style.display = 'none';
            document.getElementById('preview-img').src = '';
        }

        function addChallengeMode() {
            waitingForChallenge = true;
            currentTool = null;
            selectedObject = null;
            canvas.style.cursor = 'cell';

            // If we were editing, this becomes a "place elsewhere" action
            if (editingChallengeId) {
                // Keep the editing ID so the challenge will be moved on next click
            }

            updateCurrentMode();
            alert('Cliquez sur le canvas pour placer le challenge');
        }

        function clearLayer(layerName) {
            if (!confirm(`Effacer tous les √©l√©ments de la couche "${layerName}" ?`)) return;

            if (layerName === 'walls') walls = [];
            else if (layerName === 'water') water = [];

            updateStats();
            render();
        }

        function updateStats() {
            document.getElementById('walls-count').textContent = walls.length;
            document.getElementById('water-count').textContent = water.length;
            document.getElementById('objects-count').textContent = objects.length;
            document.getElementById('challenge-count').textContent = challenges.length;
        }

        function updateCurrentMode() {
            let mode = 'S√©lection';
            let tool = 'Aucun';

            if (waitingForChallenge) {
                mode = 'Placement Challenge';
                tool = 'Cliquez pour placer';
            } else if (selectedObject) {
                mode = 'Placement Objet';
                tool = selectedObject;
            } else if (currentTool === 'wall') {
                mode = 'Dessin';
                tool = 'üß± Mur';
            } else if (currentTool === 'water') {
                mode = 'Dessin';
                tool = 'üíß Eau';
            } else if (currentTool === 'eraser') {
                mode = 'Effacement';
                tool = 'üóëÔ∏è Gomme';
            }

            document.getElementById('current-mode').textContent = mode;
            document.getElementById('current-tool').textContent = tool;
        }

        function switchTab(tabName) {
            activeTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
            document.getElementById(`tab-${tabName}`).style.display = 'block';

            document.getElementById('current-layer').textContent =
                tabName === 'terrain' ? 'Terrain' :
                tabName === 'objects' ? 'Objets' :
                tabName === 'challenges' ? 'Challenges' : 'Configuration';
        }

        function updateGridSize() {
            gridSize = parseInt(document.getElementById('grid-size-input').value);
            document.getElementById('grid-size').textContent = gridSize;
            render();
        }

        function loadMapFromURL() {
            const url = document.getElementById('map-url').value;
            if (!url) return;

            mapImage = new Image();
            mapImage.onload = () => render();
            mapImage.onerror = () => {
                alert('Erreur de chargement de l\'image');
                mapImage = null;
                render();
            };
            mapImage.src = url;
        }

        document.getElementById('map-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                mapImage = new Image();
                mapImage.onload = () => render();
                mapImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function editChallenge(id) {
            const challenge = challenges.find(ch => ch.id === id);
            if (!challenge) return;

            // Load challenge data into form fields
            document.getElementById('new-name').value = challenge.name;
            document.getElementById('new-type').value = challenge.type;
            document.getElementById('new-icon').value = challenge.icon;
            document.getElementById('new-color').value = challenge.color;
            document.getElementById('new-radius').value = challenge.triggerRadius;
            document.getElementById('new-dialogue').value = challenge.dialogue_preview || '';

            // Load outcomes
            document.getElementById('outcome-success-triumph').value = challenge.outcomes.success_triumph || '';
            document.getElementById('outcome-success-narrow').value = challenge.outcomes.success_narrow || '';
            document.getElementById('outcome-fail-narrow').value = challenge.outcomes.fail_narrow || '';
            document.getElementById('outcome-fail-catastrophic').value = challenge.outcomes.fail_catastrophic || '';

            // Load health effects
            document.getElementById('hp-success-triumph').value = challenge.healthEffects.success_triumph || 0;
            document.getElementById('hp-success-narrow').value = challenge.healthEffects.success_narrow || 0;
            document.getElementById('hp-fail-narrow').value = challenge.healthEffects.fail_narrow || 0;
            document.getElementById('hp-fail-catastrophic').value = challenge.healthEffects.fail_catastrophic || 0;

            // Update selected icon
            selectedIcon = challenge.icon;
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.textContent.includes(challenge.icon));
            });

            // Load image if exists
            if (challenge.image) {
                currentChallengeImage = challenge.image;
                document.getElementById('preview-img').src = challenge.image;
                document.getElementById('challenge-image-preview').style.display = 'block';
            } else {
                clearChallengeImage();
            }

            // Set editing mode
            editingChallengeId = id;

            // Show save button
            document.getElementById('save-edit-btn').style.display = 'inline-block';

            // Scroll to top of the form
            document.getElementById('tab-challenges').scrollTop = 0;

            alert('Challenge charg√© pour √©dition. Modifiez les champs et cliquez sur "Sauvegarder les modifications".');
        }

        function saveEditedChallenge() {
            if (!editingChallengeId) return;

            const challenge = challenges.find(ch => ch.id === editingChallengeId);
            if (!challenge) return;

            // Update challenge data without moving it
            challenge.name = document.getElementById('new-name').value || 'Nouveau Challenge';
            challenge.type = document.getElementById('new-type').value;
            challenge.icon = selectedIcon;
            challenge.color = document.getElementById('new-color').value;
            challenge.triggerRadius = parseInt(document.getElementById('new-radius').value);
            challenge.dialogue_preview = document.getElementById('new-dialogue').value || 'Un challenge appara√Æt...';

            // Update outcomes
            challenge.outcomes = {
                success_narrow: document.getElementById('outcome-success-narrow').value || 'Vous r√©ussissez de justesse.',
                success_triumph: document.getElementById('outcome-success-triumph').value || 'Vous triomphez brillamment.',
                fail_narrow: document.getElementById('outcome-fail-narrow').value || 'Vous √©chouez mais survivez.',
                fail_catastrophic: document.getElementById('outcome-fail-catastrophic').value || '√âchec catastrophique.'
            };

            // Update health effects
            challenge.healthEffects = {
                success_triumph: parseInt(document.getElementById('hp-success-triumph').value) || 0,
                success_narrow: parseInt(document.getElementById('hp-success-narrow').value) || 0,
                fail_narrow: parseInt(document.getElementById('hp-fail-narrow').value) || -1,
                fail_catastrophic: parseInt(document.getElementById('hp-fail-catastrophic').value) || -2
            };

            // Update image
            if (currentChallengeImage) {
                challenge.image = currentChallengeImage;
            } else {
                // Remove image if it was cleared
                delete challenge.image;
            }

            // Reset editing mode
            editingChallengeId = null;
            document.getElementById('save-edit-btn').style.display = 'none';

            // Clear image preview
            clearChallengeImage();

            updateChallengesList();
            render();

            alert('Challenge modifi√© avec succ√®s!');
        }

        function deleteChallenge(id) {
            challenges = challenges.filter(ch => ch.id !== id);
            updateChallengesList();
            render();
        }

        function deleteObject(index) {
            objects.splice(index, 1);
            updateObjectsList();
            render();
        }

        function updateChallengesList() {
            const list = document.getElementById('challenges-list');
            document.getElementById('challenge-count').textContent = challenges.length;

            if (challenges.length === 0) {
                list.innerHTML = '<em style="color:#888">Aucun challenge plac√©</em>';
                return;
            }

            list.innerHTML = challenges.map(ch => `
                <div class="challenge-item">
                    <strong>${ch.icon} ${ch.name}</strong><br>
                    <span class="coords">Position: (${ch.coordinates.x}, ${ch.coordinates.y})</span><br>
                    <small>Type: ${ch.type} | Rayon: ${ch.triggerRadius}</small><br>
                    <button onclick="editChallenge('${ch.id}')">‚úèÔ∏è √âditer</button>
                    <button class="delete" onclick="deleteChallenge('${ch.id}')">üóëÔ∏è Supprimer</button>
                </div>
            `).join('');
        }

        function updateObjectsList() {
            const list = document.getElementById('objects-list');
            document.getElementById('objects-count').textContent = objects.length;

            if (objects.length === 0) {
                list.innerHTML = '<em style="color:#888">Aucun objet plac√©</em>';
                return;
            }

            list.innerHTML = objects.map((obj, i) => `
                <div class="object-item">
                    <strong>${obj.emoji}</strong><br>
                    <span class="coords">Position: (${obj.x}, ${obj.y})</span><br>
                    <button class="delete" onclick="deleteObject(${i})">üóëÔ∏è Supprimer</button>
                </div>
            `).join('');
        }

        function validateChallenges() {
            const errors = [];
            const warnings = [];

            challenges.forEach((challenge, index) => {
                const cNum = index + 1;

                // Check required fields
                if (!challenge.name || challenge.name === 'Nouveau Challenge') {
                    warnings.push(`Challenge #${cNum}: Nom par d√©faut utilis√©`);
                }
                if (!challenge.dialogue_preview) {
                    warnings.push(`Challenge #${cNum} (${challenge.name}): Dialogue de pr√©visualisation manquant`);
                }

                // Check outcomes
                const outcomes = challenge.outcomes || {};
                if (!outcomes.success_narrow || !outcomes.success_triumph ||
                    !outcomes.fail_narrow || !outcomes.fail_catastrophic) {
                    errors.push(`Challenge #${cNum} (${challenge.name}): Tous les r√©sultats (4) doivent √™tre d√©finis`);
                }

                // Check healthEffects (CRITICAL)
                if (!challenge.healthEffects) {
                    errors.push(`Challenge #${cNum} (${challenge.name}): healthEffects manquant - REQUIS pour le jeu!`);
                } else {
                    const he = challenge.healthEffects;
                    if (he.success_triumph === undefined || he.success_narrow === undefined ||
                        he.fail_narrow === undefined || he.fail_catastrophic === undefined) {
                        errors.push(`Challenge #${cNum} (${challenge.name}): healthEffects incomplet`);
                    }
                }

                // Check coordinates
                if (!challenge.coordinates || challenge.coordinates.x === undefined || challenge.coordinates.y === undefined) {
                    errors.push(`Challenge #${cNum} (${challenge.name}): Coordonn√©es manquantes`);
                }
            });

            return { errors, warnings };
        }

        function exportJSON() {
            // Validate before export
            const validation = validateChallenges();

            if (validation.errors.length > 0) {
                alert('‚ùå ERREURS CRITIQUES - Export annul√©:\n\n' + validation.errors.join('\n') + '\n\nCorrigez ces erreurs avant d\'exporter.');
                return;
            }

            if (validation.warnings.length > 0) {
                if (!confirm('‚ö†Ô∏è AVERTISSEMENTS:\n\n' + validation.warnings.join('\n') + '\n\nContinuer quand m√™me?')) {
                    return;
                }
            }

            const config = {
                mapFile: document.getElementById('map-url').value || 'assets/level1.png',
                gridSize: gridSize,
                startPos: {
                    x: parseInt(document.getElementById('start-x').value),
                    y: parseInt(document.getElementById('start-y').value)
                },
                mechanics: {
                    catastropheMax: 3,
                    healthMax: parseInt(document.getElementById('max-health').value) || 3,
                    cards: {
                        success_narrow: {label: "R√©ussite de justesse", catastropheCost: 1, outcomeType: "success"},
                        success_triumph: {label: "R√©ussite triomphale", catastropheCost: 2, outcomeType: "success"},
                        fail_narrow: {label: "√âchec de justesse", catastropheCost: 0, outcomeType: "fail"},
                        fail_catastrophic: {label: "√âchec catastrophique", catastropheCost: 0, outcomeType: "fail_crit"}
                    }
                },
                walls: walls,
                water: water,
                objects: objects,
                challenges: challenges
            };

            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'level-complete.json';
            a.click();

            console.log('‚úÖ Export r√©ussi avec validation compl√®te');
        }

        function copyJSON() {
            // Validate before copy
            const validation = validateChallenges();

            if (validation.errors.length > 0) {
                alert('‚ùå ERREURS CRITIQUES - Copie annul√©e:\n\n' + validation.errors.join('\n') + '\n\nCorrigez ces erreurs avant de copier.');
                return;
            }

            const config = {
                mapFile: document.getElementById('map-url').value || 'assets/level1.png',
                gridSize: gridSize,
                startPos: {
                    x: parseInt(document.getElementById('start-x').value),
                    y: parseInt(document.getElementById('start-y').value)
                },
                mechanics: {
                    catastropheMax: 3,
                    healthMax: parseInt(document.getElementById('max-health').value) || 3,
                    cards: {
                        success_narrow: {label: "R√©ussite de justesse", catastropheCost: 1, outcomeType: "success"},
                        success_triumph: {label: "R√©ussite triomphale", catastropheCost: 2, outcomeType: "success"},
                        fail_narrow: {label: "√âchec de justesse", catastropheCost: 0, outcomeType: "fail"},
                        fail_catastrophic: {label: "√âchec catastrophique", catastropheCost: 0, outcomeType: "fail_crit"}
                    }
                },
                walls: walls,
                water: water,
                objects: objects,
                challenges: challenges
            };

            const json = JSON.stringify(config, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                let message = '‚úÖ JSON copi√© dans le presse-papier!';
                if (validation.warnings.length > 0) {
                    message += '\n\n‚ö†Ô∏è Avertissements:\n' + validation.warnings.join('\n');
                }
                alert(message);
            });
        }

        function importJSON() {
            const file = document.getElementById('json-upload').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.mapFile) {
                        document.getElementById('map-url').value = data.mapFile;
                        loadMapFromURL();
                    }

                    if (data.gridSize) {
                        gridSize = data.gridSize;
                        document.getElementById('grid-size-input').value = gridSize;
                        document.getElementById('grid-size').textContent = gridSize;
                    }

                    if (data.startPos) {
                        document.getElementById('start-x').value = data.startPos.x;
                        document.getElementById('start-y').value = data.startPos.y;
                        startPos = data.startPos;
                    }

                    // Support both old and new formats
                    if (data.mechanics && data.mechanics.healthMax) {
                        document.getElementById('max-health').value = data.mechanics.healthMax;
                    } else if (data.maxHealth) {
                        document.getElementById('max-health').value = data.maxHealth;
                    }

                    walls = data.walls || [];
                    water = data.water || [];
                    objects = data.objects || [];
                    challenges = data.challenges || [];

                    updateStats();
                    updateChallengesList();
                    updateObjectsList();
                    render();

                    // Validate imported data
                    const validation = validateChallenges();
                    let message = '‚úÖ Configuration import√©e avec succ√®s!';

                    if (validation.errors.length > 0) {
                        message += '\n\n‚ùå ERREURS trouv√©es:\n' + validation.errors.join('\n');
                    }

                    if (validation.warnings.length > 0) {
                        message += '\n\n‚ö†Ô∏è Avertissements:\n' + validation.warnings.join('\n');
                    }

                    alert(message);
                } catch (error) {
                    alert('Erreur lors de l\'import: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function render() {
            // Clear
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw map or grid
            if (mapImage && mapImage.complete) {
                ctx.globalAlpha = 0.7;
                ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Draw grid
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw walls with stone texture
            for (let wall of walls) {
                const wx = wall.x * gridSize;
                const wy = wall.y * gridSize;

                // Base stone color - dark brown
                ctx.fillStyle = '#3d2f27';
                ctx.fillRect(wx, wy, gridSize, gridSize);

                // Add stone texture with multiple shades
                const stoneShades = [
                    '#2a1f1a', // Very dark brown
                    '#4a3a30', // Medium brown
                    '#554439', // Light brown
                    '#1f1812', // Almost black
                    '#6b5547'  // Lighter accent
                ];

                // Random-looking but deterministic stone pattern based on position
                const seed = wall.x * 13 + wall.y * 17;
                ctx.globalAlpha = 0.6;

                // Draw stone blocks/cracks
                for (let i = 0; i < 8; i++) {
                    const blockX = wx + ((seed * (i + 1) * 7) % (gridSize - 4));
                    const blockY = wy + ((seed * (i + 2) * 11) % (gridSize - 4));
                    const blockW = 3 + ((seed * (i + 3)) % 5);
                    const blockH = 3 + ((seed * (i + 4)) % 5);

                    ctx.fillStyle = stoneShades[i % stoneShades.length];
                    ctx.fillRect(blockX, blockY, blockW, blockH);
                }

                ctx.globalAlpha = 1.0;

                // Add mortar lines between stones
                ctx.strokeStyle = '#1a1410';
                ctx.lineWidth = 1;

                // Horizontal mortar lines
                const numHLines = 2;
                for (let h = 1; h <= numHLines; h++) {
                    const y = wy + (gridSize / (numHLines + 1)) * h;
                    ctx.beginPath();
                    ctx.moveTo(wx, y);
                    ctx.lineTo(wx + gridSize, y);
                    ctx.stroke();
                }

                // Vertical mortar lines (staggered)
                const numVLines = 1;
                for (let v = 1; v <= numVLines; v++) {
                    const x = wx + (gridSize / (numVLines + 1)) * v;
                    const offsetY = (wall.y % 2 === 0) ? 0 : gridSize / 3;
                    ctx.beginPath();
                    ctx.moveTo(x, wy + offsetY);
                    ctx.lineTo(x, wy + gridSize);
                    ctx.stroke();
                }

                // Dark border for depth
                ctx.strokeStyle = '#0d0a08';
                ctx.lineWidth = 2;
                ctx.strokeRect(wx, wy, gridSize, gridSize);

                // Light edge highlight for 3D effect
                ctx.strokeStyle = '#5a4a3f';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(wx + 1, wy + gridSize - 1);
                ctx.lineTo(wx + 1, wy + 1);
                ctx.lineTo(wx + gridSize - 1, wy + 1);
                ctx.stroke();
            }

            // Draw water
            ctx.fillStyle = '#1e90ff';
            ctx.globalAlpha = 0.6;
            for (let w of water) {
                const wx = w.x * gridSize;
                const wy = w.y * gridSize;
                ctx.fillRect(wx, wy, gridSize, gridSize);
            }
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = '#0066cc';
            ctx.lineWidth = 1;
            for (let w of water) {
                const wx = w.x * gridSize;
                const wy = w.y * gridSize;
                ctx.strokeRect(wx, wy, gridSize, gridSize);
            }

            // Draw objects
            ctx.font = '28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (let obj of objects) {
                const ox = obj.x * gridSize + gridSize/2;
                const oy = obj.y * gridSize + gridSize/2;

                // Shadow
                ctx.fillStyle = '#000';
                ctx.globalAlpha = 0.3;
                ctx.fillText(obj.emoji, ox + 2, oy + 2);
                ctx.globalAlpha = 1.0;

                // Emoji
                ctx.fillText(obj.emoji, ox, oy);
            }

            // Draw start position
            const sx = startPos.x * gridSize;
            const sy = startPos.y * gridSize;
            ctx.fillStyle = '#00ff00';
            ctx.globalAlpha = 0.5;
            ctx.fillRect(sx, sy, gridSize, gridSize);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(sx, sy, gridSize, gridSize);
            ctx.font = '20px Arial';
            ctx.fillText('üö∂', sx + gridSize/2, sy + gridSize/2);

            // Draw challenges
            for (let ch of challenges) {
                const cx = ch.coordinates.x * gridSize;
                const cy = ch.coordinates.y * gridSize;

                ctx.fillStyle = ch.color;
                ctx.globalAlpha = 0.6;
                ctx.fillRect(cx, cy, gridSize, gridSize);
                ctx.globalAlpha = 1;

                ctx.strokeStyle = ch.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(cx, cy, gridSize, gridSize);

                ctx.font = '24px Arial';
                ctx.fillText(ch.icon, cx + gridSize/2, cy + gridSize/2);
            }

            // Reset
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }

        // Initial state
        updateStats();
        updateChallengesList();
        updateObjectsList();
        updateCurrentMode();
    </script>
</body>
</html>

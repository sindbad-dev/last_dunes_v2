<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Suite de Tests Compl√®te - Last Dunes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }

        h1 {
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }

        .test-section {
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .test-section h2 {
            color: #4CAF50;
            margin-bottom: 15px;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        .test-case {
            background: #333;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #666;
        }

        .test-case.running {
            border-left-color: #ff9800;
        }

        .test-case.success {
            border-left-color: #4CAF50;
        }

        .test-case.failure {
            border-left-color: #f44336;
        }

        .test-name {
            font-weight: bold;
            margin-bottom: 8px;
        }

        .test-result {
            font-size: 12px;
            color: #aaa;
        }

        .test-result.success {
            color: #4CAF50;
        }

        .test-result.failure {
            color: #f44336;
        }

        .test-details {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            padding: 5px;
            background: #2a2a2a;
            border-radius: 3px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #45a049;
        }

        button.run-all {
            background: #2196F3;
        }

        button.run-all:hover {
            background: #0b7dda;
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .summary {
            background: #2a2a2a;
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .summary h3 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }

        .stat {
            padding: 10px 20px;
            border-radius: 5px;
        }

        .stat.total {
            background: #444;
        }

        .stat.passed {
            background: #4CAF50;
        }

        .stat.failed {
            background: #f44336;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
        }

        .stat-label {
            font-size: 12px;
            color: #ccc;
        }

        .logs {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
            margin-top: 10px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px;
        }

        .log-entry.info {
            color: #2196F3;
        }

        .log-entry.success {
            color: #4CAF50;
        }

        .log-entry.error {
            color: #f44336;
        }

        .log-entry.warn {
            color: #ff9800;
        }
    </style>
</head>
<body>
    <h1>üß™ Suite de Tests Compl√®te - Last Dunes</h1>

    <div class="summary" id="summary">
        <h3>üìä R√©sum√© des Tests</h3>
        <div class="summary-stats">
            <div class="stat total">
                <div class="stat-number" id="total-tests">0</div>
                <div class="stat-label">Total</div>
            </div>
            <div class="stat passed">
                <div class="stat-number" id="passed-tests">0</div>
                <div class="stat-label">R√©ussis</div>
            </div>
            <div class="stat failed">
                <div class="stat-number" id="failed-tests">0</div>
                <div class="stat-label">√âchou√©s</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="run-all" onclick="runAllTests()">‚ñ∂Ô∏è Ex√©cuter Tous les Tests</button>
        <button onclick="runChallengeEditorTests()">üå≥ Tests Challenge Editor</button>
        <button onclick="runNiveauEditorTests()">üó∫Ô∏è Tests Niveau Editor</button>
        <button onclick="runIntegrationTests()">üîó Tests Int√©gration</button>
        <button onclick="runMainJsTests()">‚öôÔ∏è Tests Main.js</button>
    </div>

    <div id="logs-container" style="margin-bottom: 20px;">
        <h3 style="color: #ffd700; margin-bottom: 10px;">üìù Logs d'Ex√©cution</h3>
        <div class="logs" id="logs"></div>
    </div>

    <!-- Section 1: Tests Challenge Editor -->
    <div class="test-section" id="challenge-editor-tests">
        <h2>üå≥ Tests de l'√âditeur de Challenge</h2>
        <div id="challenge-tests-container"></div>
    </div>

    <!-- Section 2: Tests Niveau Editor -->
    <div class="test-section" id="niveau-editor-tests">
        <h2>üó∫Ô∏è Tests de l'√âditeur de Niveau</h2>
        <div id="niveau-tests-container"></div>
    </div>

    <!-- Section 3: Tests d'Int√©gration -->
    <div class="test-section" id="integration-tests">
        <h2>üîó Tests d'Int√©gration JSON</h2>
        <div id="integration-tests-container"></div>
    </div>

    <!-- Section 4: Tests Main.js -->
    <div class="test-section" id="mainjs-tests">
        <h2>‚öôÔ∏è Tests de Chargement Main.js</h2>
        <div id="mainjs-tests-container"></div>
    </div>

    <script>
        // √âtat global des tests
        const testState = {
            total: 0,
            passed: 0,
            failed: 0,
            results: []
        };

        // Logger
        function log(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsDiv.appendChild(entry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        // Mise √† jour du r√©sum√©
        function updateSummary() {
            document.getElementById('total-tests').textContent = testState.total;
            document.getElementById('passed-tests').textContent = testState.passed;
            document.getElementById('failed-tests').textContent = testState.failed;
        }

        // Classe de test
        class TestCase {
            constructor(name, testFn, container) {
                this.name = name;
                this.testFn = testFn;
                this.container = container;
                this.element = null;
                testState.total++;
            }

            async run() {
                this.element = this.createTestElement();
                this.container.appendChild(this.element);
                this.setStatus('running');

                log(`Ex√©cution: ${this.name}`, 'info');

                try {
                    await this.testFn();
                    this.setStatus('success', '‚úÖ Test r√©ussi');
                    testState.passed++;
                    log(`‚úÖ ${this.name} - R√âUSSI`, 'success');
                    return true;
                } catch (error) {
                    this.setStatus('failure', `‚ùå ${error.message}`);
                    testState.failed++;
                    log(`‚ùå ${this.name} - √âCHOU√â: ${error.message}`, 'error');
                    return false;
                }
            }

            createTestElement() {
                const div = document.createElement('div');
                div.className = 'test-case';
                div.innerHTML = `
                    <div class="test-name">${this.name}</div>
                    <div class="test-result">En attente...</div>
                    <div class="test-details"></div>
                `;
                return div;
            }

            setStatus(status, message = '') {
                this.element.className = `test-case ${status}`;
                const resultDiv = this.element.querySelector('.test-result');
                resultDiv.className = `test-result ${status}`;
                resultDiv.textContent = message;
            }

            setDetails(details) {
                const detailsDiv = this.element.querySelector('.test-details');
                detailsDiv.textContent = details;
            }
        }

        // ==========================================
        // TESTS CHALLENGE EDITOR
        // ==========================================

        async function runChallengeEditorTests() {
            log('=== D√âBUT DES TESTS CHALLENGE EDITOR ===', 'info');
            const container = document.getElementById('challenge-tests-container');
            container.innerHTML = '';

            const tests = [
                new TestCase('Cr√©ation d\'un n≈ìud', async () => {
                    const node = {
                        id: 'test_node_1',
                        name: 'Test Challenge',
                        type: 'challenge',
                        icon: '‚öîÔ∏è',
                        color: '#ff00ff',
                        dialogue: 'Test dialogue',
                        isStart: true,
                        x: 50,
                        y: 50,
                        outcomes: {
                            success_triumph: {
                                text: 'Test triumph',
                                cost: 2,
                                type: 'success',
                                healthChange: 0
                            },
                            success_narrow: {
                                text: 'Test narrow',
                                cost: 1,
                                type: 'success',
                                healthChange: 0
                            },
                            fail_narrow: {
                                text: 'Test fail narrow',
                                cost: 0,
                                type: 'fail',
                                healthChange: -1
                            },
                            fail_catastrophic: {
                                text: 'Test catastrophic',
                                cost: 0,
                                type: 'fail',
                                healthChange: -2
                            }
                        },
                        rewardCard: null
                    };

                    if (!node.id || !node.name || !node.outcomes) {
                        throw new Error('Structure de n≈ìud invalide');
                    }

                    if (Object.keys(node.outcomes).length !== 4) {
                        throw new Error('Le n≈ìud doit avoir 4 outcomes');
                    }
                }, container),

                new TestCase('Validation des health changes', async () => {
                    const healthChanges = [-2, -1, 0, 0];

                    for (let hc of healthChanges) {
                        if (hc < -10 || hc > 10) {
                            throw new Error(`Health change ${hc} hors limites (-10 √† +10)`);
                        }
                    }
                }, container),

                new TestCase('Cr√©ation d\'une carte r√©compense', async () => {
                    const rewardCard = {
                        name: '√©p√©e_test',
                        label: '√âp√©e de Test',
                        description: 'Une √©p√©e pour tester',
                        icon: '‚öîÔ∏è',
                        cost: 1,
                        outcomeType: 'success',
                        outcomeText: 'Vous frappez avec l\'√©p√©e !',
                        healthChange: 0,
                        uses: 3
                    };

                    if (!rewardCard.name || !rewardCard.label) {
                        throw new Error('Carte r√©compense incompl√®te');
                    }

                    if (rewardCard.uses < 1 || rewardCard.uses > 10) {
                        throw new Error('Uses doit √™tre entre 1 et 10');
                    }
                }, container),

                new TestCase('Export JSON narrative tree', async () => {
                    const narrativeTree = {
                        nodes: [
                            {
                                id: 'node_0',
                                name: 'Test Node',
                                type: 'challenge',
                                icon: '‚öîÔ∏è',
                                color: '#ff00ff',
                                dialogue: 'Test',
                                isStart: true,
                                x: 50,
                                y: 50,
                                outcomes: {
                                    success_triumph: {
                                        text: 'Test',
                                        cost: 2,
                                        type: 'success',
                                        healthChange: 0
                                    },
                                    success_narrow: {
                                        text: 'Test',
                                        cost: 1,
                                        type: 'success',
                                        healthChange: 0
                                    },
                                    fail_narrow: {
                                        text: 'Test',
                                        cost: 0,
                                        type: 'fail',
                                        healthChange: -1
                                    },
                                    fail_catastrophic: {
                                        text: 'Test',
                                        cost: 0,
                                        type: 'fail',
                                        healthChange: -2
                                    }
                                },
                                rewardCard: null
                            }
                        ],
                        connections: []
                    };

                    const json = JSON.stringify(narrativeTree, null, 2);
                    const parsed = JSON.parse(json);

                    if (!parsed.nodes || !parsed.connections) {
                        throw new Error('Structure JSON invalide');
                    }

                    if (parsed.nodes.length !== 1) {
                        throw new Error('Nombre de n≈ìuds incorrect');
                    }
                }, container),

                new TestCase('Connexions entre n≈ìuds', async () => {
                    const connection = {
                        from: 'node_0',
                        fromOutcome: 'success_triumph',
                        to: 'node_1'
                    };

                    if (!connection.from || !connection.fromOutcome || !connection.to) {
                        throw new Error('Connexion incompl√®te');
                    }

                    const validOutcomes = ['success_triumph', 'success_narrow', 'fail_narrow', 'fail_catastrophic'];
                    if (!validOutcomes.includes(connection.fromOutcome)) {
                        throw new Error('Outcome invalide pour la connexion');
                    }
                }, container)
            ];

            for (let test of tests) {
                await test.run();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            updateSummary();
            log('=== FIN DES TESTS CHALLENGE EDITOR ===', 'info');
        }

        // ==========================================
        // TESTS NIVEAU EDITOR
        // ==========================================

        async function runNiveauEditorTests() {
            log('=== D√âBUT DES TESTS NIVEAU EDITOR ===', 'info');
            const container = document.getElementById('niveau-tests-container');
            container.innerHTML = '';

            const tests = [
                new TestCase('Import d\'arbre narratif', async () => {
                    const narrativeTree = {
                        nodes: [
                            {
                                id: 'node_0',
                                name: 'Test',
                                type: 'challenge',
                                icon: '‚öîÔ∏è',
                                color: '#ff00ff',
                                dialogue: 'Test dialogue',
                                isStart: true,
                                x: 50,
                                y: 50,
                                outcomes: {},
                                rewardCard: null
                            }
                        ],
                        connections: []
                    };

                    if (!narrativeTree.nodes || !Array.isArray(narrativeTree.nodes)) {
                        throw new Error('Format d\'arbre narratif invalide');
                    }

                    if (narrativeTree.nodes.length === 0) {
                        throw new Error('L\'arbre narratif doit contenir au moins un n≈ìud');
                    }
                }, container),

                new TestCase('Placement de challenge sur carte', async () => {
                    const challenge = {
                        id: 'node_0',
                        coordinates: {
                            x: 14,
                            y: 18
                        },
                        triggerRadius: 1,
                        outcomes: {
                            success_triumph: {
                                text: 'Test',
                                cost: 2,
                                type: 'success',
                                healthChange: 0
                            },
                            success_narrow: {
                                text: 'Test',
                                cost: 1,
                                type: 'success',
                                healthChange: 0
                            },
                            fail_narrow: {
                                text: 'Test',
                                cost: 0,
                                type: 'fail',
                                healthChange: -1
                            },
                            fail_catastrophic: {
                                text: 'Test',
                                cost: 0,
                                type: 'fail',
                                healthChange: -2
                            }
                        }
                    };

                    if (!challenge.coordinates || !challenge.coordinates.x || challenge.coordinates.y === undefined) {
                        throw new Error('Coordonn√©es manquantes');
                    }

                    if (!challenge.triggerRadius || challenge.triggerRadius < 1) {
                        throw new Error('Trigger radius invalide');
                    }
                }, container),

                new TestCase('Configuration de la grille', async () => {
                    const config = {
                        mapFile: 'assets/level1.png',
                        gridSize: 40,
                        startPos: {
                            x: 16,
                            y: 25
                        }
                    };

                    if (!config.mapFile) {
                        throw new Error('Fichier de carte manquant');
                    }

                    if (!config.gridSize || config.gridSize < 1) {
                        throw new Error('Taille de grille invalide');
                    }

                    if (!config.startPos || config.startPos.x === undefined || config.startPos.y === undefined) {
                        throw new Error('Position de d√©part invalide');
                    }
                }, container),

                new TestCase('Ajout de terrain (murs, eau, objets)', async () => {
                    const terrain = {
                        walls: [{x: 10, y: 5}],
                        water: [{x: 8, y: 12}],
                        objects: [{x: 15, y: 10, icon: 'üå¥', color: '#00ff00'}]
                    };

                    if (!Array.isArray(terrain.walls) || !Array.isArray(terrain.water) || !Array.isArray(terrain.objects)) {
                        throw new Error('Terrain doit contenir des tableaux');
                    }

                    for (let wall of terrain.walls) {
                        if (wall.x === undefined || wall.y === undefined) {
                            throw new Error('Mur sans coordonn√©es');
                        }
                    }
                }, container),

                new TestCase('Export level-complete.json', async () => {
                    const levelComplete = {
                        mapFile: 'assets/level1.png',
                        gridSize: 40,
                        startPos: {x: 16, y: 25},
                        walls: [],
                        water: [],
                        objects: [],
                        challenges: [
                            {
                                id: 'node_0',
                                coordinates: {x: 14, y: 18},
                                triggerRadius: 1,
                                outcomes: {
                                    success_triumph: {text: 'Test', cost: 2, type: 'success', healthChange: 0},
                                    success_narrow: {text: 'Test', cost: 1, type: 'success', healthChange: 0},
                                    fail_narrow: {text: 'Test', cost: 0, type: 'fail', healthChange: -1},
                                    fail_catastrophic: {text: 'Test', cost: 0, type: 'fail', healthChange: -2}
                                }
                            }
                        ],
                        narrativeTree: {
                            nodes: [{
                                id: 'node_0',
                                name: 'Test',
                                type: 'challenge',
                                icon: '‚öîÔ∏è',
                                color: '#ff00ff',
                                dialogue: 'Test',
                                isStart: true,
                                x: 50,
                                y: 50,
                                outcomes: {},
                                rewardCard: null
                            }],
                            connections: []
                        }
                    };

                    const required = ['mapFile', 'gridSize', 'startPos', 'challenges', 'narrativeTree'];
                    for (let prop of required) {
                        if (!levelComplete[prop]) {
                            throw new Error(`Propri√©t√© manquante: ${prop}`);
                        }
                    }

                    const json = JSON.stringify(levelComplete, null, 2);
                    JSON.parse(json); // Validation JSON
                }, container)
            ];

            for (let test of tests) {
                await test.run();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            updateSummary();
            log('=== FIN DES TESTS NIVEAU EDITOR ===', 'info');
        }

        // ==========================================
        // TESTS D'INT√âGRATION
        // ==========================================

        async function runIntegrationTests() {
            log('=== D√âBUT DES TESTS D\'INT√âGRATION ===', 'info');
            const container = document.getElementById('integration-tests-container');
            container.innerHTML = '';

            const tests = [
                new TestCase('V√©rification fichier level-complete.json', async () => {
                    try {
                        const response = await fetch('data/level-complete.json');
                        if (!response.ok) {
                            throw new Error(`Fichier non trouv√© (HTTP ${response.status})`);
                        }
                        const data = await response.json();

                        if (!data) {
                            throw new Error('Fichier vide ou JSON invalide');
                        }
                    } catch (error) {
                        throw new Error(`Impossible de charger level-complete.json: ${error.message}`);
                    }
                }, container),

                new TestCase('Validation structure level-complete.json', async () => {
                    const response = await fetch('data/level-complete.json');
                    const data = await response.json();

                    const required = ['mapFile', 'gridSize', 'startPos', 'challenges', 'narrativeTree'];
                    const missing = required.filter(prop => !data[prop]);

                    if (missing.length > 0) {
                        throw new Error(`Propri√©t√©s manquantes: ${missing.join(', ')}`);
                    }
                }, container),

                new TestCase('Validation narrativeTree', async () => {
                    const response = await fetch('data/level-complete.json');
                    const data = await response.json();

                    if (!data.narrativeTree) {
                        throw new Error('narrativeTree manquant');
                    }

                    if (!data.narrativeTree.nodes || !Array.isArray(data.narrativeTree.nodes)) {
                        throw new Error('narrativeTree.nodes invalide');
                    }

                    if (data.narrativeTree.nodes.length === 0) {
                        throw new Error('narrativeTree.nodes est vide');
                    }
                }, container),

                new TestCase('Correspondance IDs challenges <-> n≈ìuds', async () => {
                    const response = await fetch('data/level-complete.json');
                    const data = await response.json();

                    const challengeIds = data.challenges.map(c => c.id).sort();
                    const nodeIds = data.narrativeTree.nodes.map(n => n.id).sort();

                    if (challengeIds.length !== nodeIds.length) {
                        throw new Error(`Nombre diff√©rent: ${challengeIds.length} challenges vs ${nodeIds.length} n≈ìuds`);
                    }

                    for (let i = 0; i < challengeIds.length; i++) {
                        if (challengeIds[i] !== nodeIds[i]) {
                            throw new Error(`ID non correspondant: challenge "${challengeIds[i]}" vs n≈ìud "${nodeIds[i]}"`);
                        }
                    }
                }, container)
            ];

            for (let test of tests) {
                await test.run();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            updateSummary();
            log('=== FIN DES TESTS D\'INT√âGRATION ===', 'info');
        }

        // ==========================================
        // TESTS MAIN.JS
        // ==========================================

        async function runMainJsTests() {
            log('=== D√âBUT DES TESTS MAIN.JS ===', 'info');
            const container = document.getElementById('mainjs-tests-container');
            container.innerHTML = '';

            const tests = [
                new TestCase('Fonction enrichChallengesWithNarrative existe', async () => {
                    // Simulation de la fonction
                    function enrichChallengesWithNarrative(challenges, narrativeTree) {
                        if (!narrativeTree || !narrativeTree.nodes) {
                            return challenges;
                        }

                        return challenges.map(challenge => {
                            const node = narrativeTree.nodes.find(n => n.id === challenge.id);
                            if (!node) return challenge;

                            return {
                                ...challenge,
                                name: node.name || challenge.name,
                                type: node.type || challenge.type,
                                icon: node.icon || challenge.icon,
                                color: node.color || challenge.color,
                                description: node.dialogue || challenge.description,
                                dialogue_preview: node.dialogue || challenge.dialogue_preview,
                                isStart: node.isStart || false,
                                rewardCard: node.rewardCard || null
                            };
                        });
                    }

                    if (typeof enrichChallengesWithNarrative !== 'function') {
                        throw new Error('Fonction enrichChallengesWithNarrative non d√©finie');
                    }
                }, container),

                new TestCase('Enrichissement avec arbre narratif', async () => {
                    function enrichChallengesWithNarrative(challenges, narrativeTree) {
                        return challenges.map(challenge => {
                            const node = narrativeTree.nodes.find(n => n.id === challenge.id);
                            const enriched = {
                                ...challenge,
                                name: node.name,
                                icon: node.icon,
                                color: node.color
                            };

                            // Convertir outcomes d'objets √† cha√Ænes
                            if (challenge.outcomes) {
                                enriched.outcomes = {};
                                for (let outcomeType in challenge.outcomes) {
                                    const outcome = challenge.outcomes[outcomeType];
                                    enriched.outcomes[outcomeType] = typeof outcome === 'string' ? outcome : outcome.text;
                                }
                            }

                            // Extraire healthEffects
                            if (challenge.outcomes) {
                                enriched.healthEffects = {};
                                for (let outcomeType in challenge.outcomes) {
                                    const outcome = challenge.outcomes[outcomeType];
                                    if (typeof outcome === 'object' && outcome.healthChange !== undefined) {
                                        enriched.healthEffects[outcomeType] = outcome.healthChange;
                                    }
                                }
                            }

                            return enriched;
                        });
                    }

                    const challenges = [{
                        id: 'node_0',
                        coordinates: {x: 14, y: 18},
                        triggerRadius: 1,
                        outcomes: {
                            success_triumph: {text: 'Test triumph', cost: 2, healthChange: 0},
                            success_narrow: {text: 'Test narrow', cost: 1, healthChange: 0},
                            fail_narrow: {text: 'Test fail', cost: 0, healthChange: -1},
                            fail_catastrophic: {text: 'Test cata', cost: 0, healthChange: -2}
                        }
                    }];

                    const narrativeTree = {
                        nodes: [{
                            id: 'node_0',
                            name: 'Le Gobelin',
                            icon: 'üë∫',
                            color: '#00ff00',
                            dialogue: 'Test'
                        }]
                    };

                    const enriched = enrichChallengesWithNarrative(challenges, narrativeTree);

                    if (enriched[0].name !== 'Le Gobelin') {
                        throw new Error('Enrichissement du nom √©chou√©');
                    }

                    if (enriched[0].icon !== 'üë∫') {
                        throw new Error('Enrichissement de l\'ic√¥ne √©chou√©');
                    }

                    if (enriched[0].color !== '#00ff00') {
                        throw new Error('Enrichissement de la couleur √©chou√©');
                    }

                    // V√©rifier conversion des outcomes
                    if (enriched[0].outcomes.success_triumph !== 'Test triumph') {
                        throw new Error('Conversion des outcomes √©chou√©e');
                    }

                    // V√©rifier extraction des healthEffects
                    if (enriched[0].healthEffects.success_triumph !== 0) {
                        throw new Error('Extraction des healthEffects √©chou√©e');
                    }
                }, container),

                new TestCase('Chargement avec priorit√© level-complete.json', async () => {
                    // Simulation du chargement
                    const levelCompleteResponse = await fetch('data/level-complete.json')
                        .then(r => r.ok ? r.json() : null)
                        .catch(() => null);

                    if (!levelCompleteResponse) {
                        throw new Error('level-complete.json n\'est pas charg√© en priorit√©');
                    }

                    log('level-complete.json charg√© avec succ√®s', 'success');
                }, container),

                new TestCase('Validation enrichissement sans arbre narratif', async () => {
                    function enrichChallengesWithNarrative(challenges, narrativeTree) {
                        if (!narrativeTree || !narrativeTree.nodes) {
                            return challenges;
                        }
                        return challenges;
                    }

                    const challenges = [{id: 'test'}];
                    const enriched = enrichChallengesWithNarrative(challenges, null);

                    if (enriched !== challenges) {
                        throw new Error('Sans arbre narratif, les challenges doivent √™tre retourn√©s tels quels');
                    }
                }, container)
            ];

            for (let test of tests) {
                await test.run();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            updateSummary();
            log('=== FIN DES TESTS MAIN.JS ===', 'info');
        }

        // ==========================================
        // EX√âCUTION GLOBALE
        // ==========================================

        async function runAllTests() {
            log('========================================', 'info');
            log('D√âBUT DE L\'EX√âCUTION DE TOUS LES TESTS', 'info');
            log('========================================', 'info');

            // R√©initialiser l'√©tat
            testState.total = 0;
            testState.passed = 0;
            testState.failed = 0;
            updateSummary();

            await runChallengeEditorTests();
            await runNiveauEditorTests();
            await runIntegrationTests();
            await runMainJsTests();

            log('========================================', 'info');
            log(`TOUS LES TESTS TERMIN√âS`, 'info');
            log(`Total: ${testState.total} | R√©ussis: ${testState.passed} | √âchou√©s: ${testState.failed}`, 'info');

            if (testState.failed === 0) {
                log('üéâ TOUS LES TESTS ONT R√âUSSI !', 'success');
            } else {
                log(`‚ö†Ô∏è ${testState.failed} test(s) ont √©chou√©`, 'warn');
            }
            log('========================================', 'info');
        }

        // Ex√©cuter automatiquement au chargement
        window.addEventListener('load', () => {
            // V√©rifier si ouvert via file://
            if (window.location.protocol === 'file:') {
                log('‚ö†Ô∏è ATTENTION: Fichier ouvert en file://', 'error');
                log('Les tests de chargement JSON √©choueront √† cause de CORS', 'warn');
                log('Solution: Lancez un serveur web local', 'warn');
                log('  python3 -m http.server 8000', 'info');
                log('  Puis ouvrez http://localhost:8000/test-suite.html', 'info');
                log('', 'info');
            }

            log('Suite de tests charg√©e. Pr√™t √† ex√©cuter.', 'info');
            log('Cliquez sur "Ex√©cuter Tous les Tests" pour commencer.', 'info');
        });
    </script>
</body>
</html>
